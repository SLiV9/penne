{"0": {
    "doc": "Error Codes",
    "title": "Error code E482",
    "content": "A goto statement jumps past a variable declaration to a label, but this variable is used afterwards. This results in a variable that is declared in some branches, but not others, which is unsound. Example of erroneous code . fn main(input: i32) -&gt; i32 { var result = 0; if input == 1 goto next; var a = 20; var b = 5; result = result + a + b; next: result = result + a; return: result } . [E482] Error: Variable declaration may be skipped ╭─[/tmp/penne_20230225-28328-118wy6v_sample.pn:10:24] │ 5 │ goto next; · ──┬─ · ╰─── A jump from this `goto` statement to 'next'... 6 │ var a = 20; · ┬ · ╰── ...may skip the declaration of the variable 'a'. · 9 │ next: · ──┬── · ╰──── After this label, the existence of 'a' is dubious. 10 │ result = result + a; · ┬ · ╰── The variable is referenced here. ────╯ . To fix this, move the variable declaration in front of the offending goto statement. fn main(input: i32) -&gt; i32 { var result = 0; var a = 20; if input == 1 goto next; var b = 5; result = result + a + b; next: result = result + a; return: result } . ",
    "url": "/penne/errors.html#error-code-e482",
    
    "relUrl": "/errors.html#error-code-e482"
  },"1": {
    "doc": "Error Codes",
    "title": "Error Codes",
    "content": " ",
    "url": "/penne/errors.html",
    
    "relUrl": "/errors.html"
  },"2": {
    "doc": "Language Features",
    "title": "Language Features",
    "content": "An overview of the more unique language features of Penne: . Scoped goto statements . In Penne, goto is a local forward-only jump. This is achieved by giving labels a reverse scope: similar to how variables cannot be referenced before they are declared, labels cannot be jumped to after they are declared. fn foo() -&gt; i32 { var x = 0; { // The scope of the label `end` ends here. goto end; x = 10; // This line is not executed. end: // The scope of the label `end` starts here. } x = x + 1; return: x } . Like variables, label scopes extend into inner blocks. Thus, a goto statement can jump out any number of nested blocks. fn foo() { var i = 1; { var x = 10; { var y = 20; i = 20; // Valid because the variable `i` is in scope here. goto end; // Valid because the label `end` is in scope here. } i = x; // This line is not executed. } end: } . In order to keep goto statements sound and easy to understand, a goto statement cannot jump into an inner block. fn foo() { goto inner; // Invalid, the label `inner` is not in scope here. var i = 1; { var x = 10; { // The scope of the label `inner` ends here. inner: // The scope of the label `inner` starts here. var y = 20; i = y; } i = x; } } . This compiler tells you that it cannot find the label in scope. [E400] Error: Undefined label ╭─[tests/samples/invalid/jump_to_inner.pn:3:12] │ 3 │ goto inner; // Invalid, the label `inner` is not in scope here. · ──┬── · ╰──── Reference to undefined label 'inner'. ───╯ . Similarly, labels that have at least one in-bound goto statement automatically prune the scope of variables declared higher up in the same block. This prevents goto statements from jumping over the declaration of a variable into code that references that variable. // ... fn overlapping(input: i32) -&gt; i32 { var result = 200; if input == 0 goto return; if input == 1 goto next; var a = 20; result = result + a; if input == 2 goto return; next: var b = 10; result = result + a + b; return: result } . In input were to equal 1, the declaration of the variable a would be skipped, which would leave the expression result + a + b undefined. The compiler refuses the compile this code. [E482] Error: Variable declaration may be skipped ╭─[tests/samples/invalid/conditional_declaration.pn:32:21] │ 25 │ goto next; · ──┬─ · ╰─── A jump from this `goto` statement to 'next'... 26 │ var a = 20; · ┬ · ╰── ...may skip the declaration of the variable 'a'. · 30 │ next: · ──┬── · ╰──── After this label, the existence of 'a' is dubious. · 32 │ result = result + a + b; · ┬ · ╰── The variable is referenced here. ────╯ . Scoped loop statements . The only way to jump back is with the loop statement. fn foo() -&gt; i32 { var x = 0; { x = x + 1; loop; } return: x // This line is never reached. } . In order to keep backward jumps isolated and easy to find, loop can only appears as the last statement in a block. Views . Function arguments other than pointers (see below), primitives and words are passed as a view. For arrays this means an array view (or “slice”) is created and passed into the function. Array views remember the length of their array, which can be accessed with the length operation |x|. fn foo() { var data: [4]i32 = [1, 2, 3, 4]; var total = sum(data); } fn sum(x: []i32) -&gt; i32 { var total = 0; var i = 0; { if i == |x| goto return; total = total + x[i]; i = i + 1; loop; } return: total } . Reference pointers . Views allow you to pass a large value by reference, but they only give immutable access. For mutable access, a pointer is needed. They can be created by taking the address of a value. Unlike in most other languages, reference pointers in Penne automatically dereference to their base type, which is any type that isn’t a reference pointer. var x: i32 = 17; var a: &amp;i32 = &amp;x; var y: i32 = a; a = 30; // Now x == 30 and y == 17. To change which value a reference pointer points to, you need to explicitly modify the address. var x: i32 = 17; var y: i32 = 30; var z: i32 = 88; var a: &amp;i32 = &amp;x; &amp;a = &amp;y; // Now a points to y instead of x. var b: &amp;i32 = &amp;z; &amp;a = &amp;b; // Now a and b both point to z. Reference pointers allow a function to modify its arguments, but require the caller to explicitly pass in an address. fn foo() { var data: [4]i32 = [1, 2, 3, 4]; set_to_zero(&amp;data); } fn set_to_zero(x: &amp;[]i32) { var i = 0; { if i == |x| goto end; x[i] = 0; i = i + 1; loop; } end: } . Structs and words . Like arrays, structural types declared with the struct keyword are implicitly passed as a view and cannot be used as the return value of a function. Fixed size structures, declared with word8, word16, word32, word64 or word128, are passed by value. Imports . The import keyword is used to import all function signatures, structures and constants marked pub from a source file into the destination file. Imports are themselves not public and hence are not re-imported. Interoperability with C . Functions marked extern use the C ABI, which means it is possible (though not necessarily safe) to call them from C code compiled by LLVM. Conversely, declaring a function header such as . extern fn foo(buffer: []u8, length: usize); . allows you to call a C function from Penne code. Interacting with other programming languages that utilize or support the C ABI, such as C++, Rust, Zig or WebAssembly, is also possible. Only array views, pointers and the primitive types i8, i16, i32, i64, u8, u16, u32, u64 and usize are allowed in the signature of an extern function. Array views in extern functions correspond to (const) pointers in C, do not have a length (|x|) and must not be null. In a future version of Penne, pointers will also be assumed to be non-null and an “optional” type must be used to mark nullable pointers. Structures and constants can also be declared extern, but as of v0.3.0 this has no effect. ",
    "url": "/penne/features.html",
    
    "relUrl": "/features.html"
  },"3": {
    "doc": "Home",
    "title": "The Penne Programming Language",
    "content": "Penne is an esoteric programming language that imagines a world where, instead of being ostracized for leading to so-called “spaghetti code”, the humble goto statement became the dominant method of control flow, surpassing for loops and switch statements, and ultimately obviating the need for the invention of RAII and object-oriented programming in general. By applying modern sensibilities to the use of the goto statement instead of banishing it altogether, Penne seeks to bring about a rennaissance of pasta-oriented programming. ",
    "url": "/penne/#the-penne-programming-language",
    
    "relUrl": "/#the-penne-programming-language"
  },"4": {
    "doc": "Home",
    "title": "A quick taste",
    "content": "Penne’s general aesthetic is inspired by modern programming languages (in particular Rust), with the notable exception of labels and the goto statement, which are (at least syntactically) taken from C, and the loop statement. // Calculate the number of Collatz steps needed to reach 1. // The Collatz conjecture states that this function always terminates. fn determine_collatz_number(start: i32) -&gt; i32 { var x = start; var steps = 0; { if x == 1 goto return; do_collatz_step(&amp;x); steps = steps + 1; loop; } return: steps } // If x is even, divide it by 2. Otherwise calculate 3 * x + 1. // Do this without division or modulo operators (for demonstrative purposes). fn do_collatz_step(x: &amp;i32) { var y = x; { if y == 0 { if y + y == x { x = y; goto end; } y = y + 1; loop; } else if y == 1 { x = 3 * x + 1; goto end; } y = y - 2; loop; } end: } . ",
    "url": "/penne/#a-quick-taste",
    
    "relUrl": "/#a-quick-taste"
  },"5": {
    "doc": "Home",
    "title": "Language features",
    "content": "Penne is characterized by: . | scoped goto statements; | automatically dereferencing pointers; | type inference; | interoperability with C. | . See Language Features for a detailed explanation. Non-features . Penne is an esoteric language, not a general purpose or systems programming language. Certain modern features that you or I may think essential for a good programming language in 2023 to have, are omitted. This is either because including them would contradict the premise of Penne (see above) or to simplify its implementation. As such, the following are decidedly not features of Penne: . | classes; | generics; | iterators; | support for pointers larger than 64 bits; | a string type guaranteed to be UTF-8; | memory safety of any kind. | . ",
    "url": "/penne/#language-features",
    
    "relUrl": "/#language-features"
  },"6": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/penne/",
    
    "relUrl": "/"
  },"7": {
    "doc": "Syntax Overview",
    "title": "Syntax Overview",
    "content": "The following codesample displays a broad range of syntax. /// Example doc-style comment. const COLOR: u32 = 0xfb4934ff; const DATA_HEIGHT: u32 = 3; const DATA: [3]u8 = [ 0b11000011, 0b10000001, 0b00100100, ]; fn determine_collatz_number(start: i32) -&gt; i32 { var x = start; var steps = 0; { if x == 1 goto return; do_collatz_step(&amp;x); steps = steps + 1; loop; } return: steps } fn do_collatz_step(x: &amp;i32) { var y = x; { if y == 0 { if y + y == x { x = y; goto end; } y = y + 1; loop; } else if y == 1 { x = 3 * x + 1; goto end; } y = y - 2; loop; } end: } fn solve_all_our_problems() { // Left as an exercise for the reader. } fn do_nothing() { nothing: } word64 Position { x: i32, y: i32, } fn sum_of_position(pos: Position) -&gt; i32 { return: pos.x + pos.y } struct FourPositions { positions: [4]Position, } pub extern fn something_with_pointers(u: &amp;&amp;i32) { var i: i32 = 17; var x: &amp;i32 = &amp;i; var a: &amp;&amp;i32 = &amp;&amp;x; &amp;&amp;a = &amp;&amp;u; var text = \"Save up to \\u{20a0}50 or \\xA350 or more!\\0\"; } fn something_with_casting() { var a: bool = true; var data: []i16 = [80, 20]; var result = a as u8 + |data| as u8; } fn main() -&gt; i32 { var from = Position { x: 10, y: 10 }; var four_positions = FourPositions { positions: [ from, Position { x: 0, y: 0 }, Position { x: from.x, y: 0 }, Position { x: 0, y: from.y }, ], }; return: 0 } . ",
    "url": "/penne/syntax.html",
    
    "relUrl": "/syntax.html"
  }
}
