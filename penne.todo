Features:
	✔	Forward-only goto's @done (2020-10-18 14:46)
	✔	Pointers with automatic dereference @done (2022-09-20 14:56)
	☐	If-statement-based pattern matching
	☐	Tagged unions for error handling

Functionality:
	✔	Void functions @done (2022-09-20 16:13)
		✔	Void type that cannot be assigned to variable/parameter/member/etc @done (2022-12-31 13:11)
			☐	Pattern matching using the type name (e.g. "void" or "!") as pattern
	✔	Fixed-length stack-based arrays @done (2022-09-03 21:22)
		✔	Array length operator @done (2022-09-04 11:48)
	✔	Multidimensional arrays @done (2022-09-19 17:28)
	✔	Pointers with automatic dereference @done (2022-09-20 14:56)
		✔	Think about (disallowing) cast between pointer and integer @done (2022-12-24 18:39)
			The only use case I care about is debugging and maybe offsets.
			☐	printf()/format() needs a %p
			☐	builtin function (&T, usize) -> &T
			☐	Error if using 0x0 to initialize a view or non-optional pointer
	✔	Pass array by const-reference (slice) by default @done (2022-09-04 18:06)
		☐	A [3]i32 parameter is typechecked as [3]i32 but implemented as []i32
		✔	In extern functions, use pointers instead of slice structs @done (2022-09-08 12:09)
	✔	String literals @done (2022-12-01 16:31)
	✔	Byte string literals @done (2022-09-22 15:22)
		☐	ASCII character literals ('a', '\n', '\0')
	✔	FFI @done (2022-09-22 15:22)
		✔	extern C fn(); @done (2022-09-05 18:38)
		✔	pub extern C fn() {...} @done (2022-09-05 16:51)
	✔	Parenthesized subexpressions @done (2023-01-15 16:07)
	✔	Named constants as array lengths @done (2023-03-23 16:17)
		✘	LengthOfArray in constant expressions @cancelled (2023-01-25 14:31)
		✔	SizeOfStructure in constant expressions @done (2023-01-25 14:31)
		✔	Think about empty arrays and structs of size 0 @done (2023-01-29 18:19)
			Follow LLVM, empty structs and empty arrays have size 0.
		✔	Must be constant, not variable @done (2023-03-23 16:18)
	✘	Boolean comparisons outside of if statement condition @cancelled (2023-02-04 18:59)
		✘	Update ctype.pn @cancelled (2023-02-04 18:59)
		✘	Boolean and, or @cancelled (2023-02-04 18:59)
	☐	Disallow function calls in comparisons or boolean expressions
	☐	Operator += etcetera
	☐	Floats
	✔	Other integer sizes @done (2022-09-05 14:30)
		✔	Think about size of usize @done (2022-12-15 19:37)
			☐	Think about this again because the LLVM C API used currently limits array lengths to u32
		✔	Different generated integer sizes for WASM and x86 @done (2022-09-23 21:56)
		✔	Think about natural stack alignment @done (2022-12-24 19:44)
		✔	Think about isize @done (2022-12-24 18:51)
		✔	Think about difference between usize and upointer @done (2022-12-24 18:51)
		☐	Allow integer type suffixes for 0x123 and 0b101
			Only u8 through u64, and becomes Token::Uint64, not Token::BitInteger
			☐	Or make sure they default to u64 and do not cause E582
	☐	Strong enums
	☐	Optional
		☐	Niches for pointers and enums
		☐	Niches in non-extern structs that have one or more bytes of padding
		☐	Ability to use weak enums to define int types with niches
	✔	Function calls @done (2021-01-16 18:03)
	✔	Function parameters @done (2021-01-16 18:03)
	✔	Structs @done (2022-12-31 13:55)
		✔	Struct parameters should be in views @done (2022-11-20 16:21)
		✔	Structs should not be packed by default @done (2022-12-15 20:50)
			✔	Sizeof operator @done (2022-12-15 19:15)
		✔	Think about allowing padded words @done (2022-12-15 18:16)
			Yes.
		✔	Think about undefined members @done (2022-12-15 18:18)
			Undefined mebers of structs are undefined, just like undefined variables.
		✔	Think about value of padding bits in word @done (2022-12-15 18:15)
			Padding bits are undefined.
		✔	Think about repr(C) and (disallowing) cast between word/struct/u128 @done (2022-12-15 18:16)
			All structs and words are repr(C). There are no casts except transmute().
		✘	Reorder non-extern words and structs to shrink their size @cancelled (2022-12-15 20:50)
		☐	Allow extern struct and words in externalize_type()
			☐	Think about explicit view translated to "const T* const"
	✘	Vec and String @cancelled (2022-12-01 15:57)
	✘	Explicit mutable parameters @cancelled (2022-09-03 16:04)
	☐	Modules
		✘	pragma once @cancelled (2023-01-05 19:05)
			✘	Prevent circular imports @cancelled (2023-01-05 19:05)
		✔	Public vs private @done (2023-01-05 19:05)
			☐	Think about pub (extern) const (not) being static
		☐	Namespacing
		☐	Use and pub use
			☐	Deduplicate symbols that are pub used in two different imports
	☐	Heap allocation
		☐	const X: &Foo = $static_alloc Foo { ... }; as a replacement for static globals
			Do not allow dereffing X in const context.
	☐	stdlib
		✔	Get lli to run import_core.pn @done (2023-03-23 16:22)
			LLVM ERROR: Tried to execute an unknown external function: is_control_char
			The second argument to lli is passed to main(), not loaded...
			So calling LLVMLinkModules2 was not overcomplicating things.
		☐	panic()
		☐	print()
		☐	fopen(), fclose()
		☐	memcpy(), memset()
			☐	wasm4 basic-drawing.md code sample versimplen
			☐	Write fix examples in error code reference for E531 through E533
		☐	transmute() implemented met bitcast (geen struct size checks)
			☐	wasm4 saving-data.md code sample versimpelen
		☐	Move main infra to library so it can be tested
			☐ Add test for import_sum_of_squares.pn
			☐	Or create an integratino test with assert_cmd crate
	☐	Compile-time string and byte-array inclusion from file

Syntactic sugar:
	☐	Operator assignment syntax (e.g. i += 1)
	☐	Pre-block scope-merging variable declarations
		var i = 0,
		{
			...
		}
		// i is not in scope here
		And similarly
		var x = foo(),
		var y = bar(),
		if x == y
		{
			...
		}
		else if x == -y
		{
			...
		}
		// x and y are not in scope here
		(Or perhaps "with" instead of "var"?)
	✔	C-style string literal concatenation @done (2021-07-10 13:26)

Syntax errors:
	These are syntax errors because they would cause errors during IR generation
	✔	Goto statement without corresponding label @done (2020-10-18 14:44)
	✔	Duplicate label @done (2020-10-18 14:44)
	✔	Non-goto statement after if without braces @done (2020-10-18 15:15)
	✔	Loop statement anywhere except at the end of a block @done (2020-10-18 15:23)
	✔	Function argument number mismatch @done (2021-01-17 16:03)
	✔	Function return value cannot be array or large struct @done (2022-10-12 15:45)

Linting errors:
	These are lints because they only cause runtime problems.
	☐	Unreachable code
		☐	gotofail bug in tests/samples/suspicious
	✔	Loop as only statement in an if-branch @done (2021-01-09 12:45)
	☐	Functions with side effects in if-statement conditions
	✘	Var declaration with undefined value in some/all branches @cancelled (2023-01-25 12:55)
		The general case is halting problem, and bespoke analysis is out of scope.
	☐	Undefined members in structure initialization
	✘	Non-extern function without body @cancelled (2023-02-04 18:01)
		Imported functions are non-pub non-extern but have external linkage.
		✘	Add external linkage to fix the import_core lli issue? @cancelled (2023-02-04 18:00)
			External linkage is already the default.
	☐	Returning pointer, slice or view of temporary
		☐	Suspicious dangling pointer (or is this out of scope for this lang?)
	☐	Private struct used in public declaration
	☐	Discarding the result of a function (but only if error-like?)
	☐	Using "\x80" in the same string as "\u{80}" or "€"

Usability:
	✔	Error recovery @done (2022-10-09 22:24)
		☐	Better error recovery when an opening brace is consumed
			☐	Experiment with structural pre-parsing phase?
		✘	Better error recovery for unmatched parentheses @cancelled (2023-01-07 20:08)
		☐	Prevent duplicate "reference to undefined struct" errors?
		☐	Better "duplicate variable" error text for parameters and members
		☐	Better "conflicting types" error text for assigning to arrays or pointers
			Because it will call 0i32 an expression of type []i32, for instance.
		☐	Avoid misleading error text in E507 if both address and type are wrong
		☐	Better error when using ; instead of , in struct definition (mention ,)
	☐	Debug symbols in the resulting IR/executable
	☐	Add helpful note when trying to jump backwards
		☐	Similarly, add note when referencing variable declared later
		☐	Add note when referencing variable from an inner scope
	✔	Allow goto to skip var declaration if short-lived (skip_shortlived_var.pn) @done (2023-01-09 17:57)
	✔	Add options to disable color and unicode symbols in errors @done (2023-03-03 17:10)
		☐	Update ariadne when fixed and remove hide(true)
		☐	Disable red in final error message when --color=never

Performance:
	☐	Add parameter attributes such as nonnull and readonly

Documentation:
	✔ Move tests from lib.rs to *tests/* @done (2022-10-04 16:44)
	☐	Reference of all current and unstable language features
	☐	Changelog.md
	☐	Tags for crates.io
	☐	Replace "total lines" github shield with "cloc src/"
	✔	High def logo @done (23-02-16 17:28)

Development:
	☐ Refactor the main flow to have a Generator with a single LLVM Context, so we can call LLVMLinkModules2, and also so that we can call the generator inside typer.rs for arraywithnamedlength
		Ah but the trouble is that we need both the pre-resolver metadata about the constants and the post-resolver generated LLVM.
		Also I need debug information in the resolved AST for DWARF.
		Perhaps just add a more traditional symbol table?
		Because I do not have global type inference, I should be able to do the stages after scoping separately for all declarations.
		Hmm except that mutability checks now has a cascading error avoidance that relies on the constant being typed before mutability::declare().
		✔	Fix tests @done (2023-03-22 15:32)
		✔	Figure out a way to undo the sort inside a fold to get the errors in the correct order @done (2023-03-22 16:29)
	  ✔	Figure out a way to forward declare structures for &Red types @done (2023-03-22 17:12)
		✘	Add a check or Declaration::Assertion for named lengths @cancelled (2023-03-23 14:48)
		✔	Add some way to forward declare a struct @done (2023-03-23 16:11)
			✘	Treat &UnresolvedStructOrWord as this during resolution @cancelled (2023-03-23 16:11)
		✔	Link modules @done (2023-03-22 15:32)
		✔	Clean up main.rs and lib.rs @done (2023-03-22 15:32)
		☐	Use typestate to encode implicit preconditions
			☐	Replace unreachable ArrayWithNamedLength with typestate
	☐	Improve test coverage
		✔	Is E163 unreachable? @done (2023-03-04 17:25)
		✔	Is E332 unreachable? @done (2023-03-04 18:35)
		✔	Is E580 unreachable? @done (2023-03-04 18:35)
		☐	Think about a better way to solve "ambiguous" errors (E332 and E580)
			☐	Separate typed AST at the end of typing stage?
		✘	Isn't it better to consume E582 into other errors if possible? @cancelled (2023-03-15 22:15)
		☐	Are E583 and E584 unreachable?
		✔	Take another look at uncovered lines in complicated match statements, because it can and did reveal impossible cases @done (2023-03-15 22:24)
		☐	Think about whether variables (declared with var) can ever be immutable due to their type, because variables currently cannot be slices and views
			☐	Remove `let is_mutable = match value_type` in mutability.rs
		☐	Rethink necessity of is_immediate_parameter in generate_storage_address()
		☐	Add tests that fully cover generate_autocoerce()
			☐	Remove need for unimplemented!() somehow?
