
	fn generate_autoderef(
		&self,
		llvm: &mut Generator,
		ref_type: &ValueType,
		deref_type: &ValueType,
	) -> Result<LLVMValueRef, anyhow::Error>
	{
		match (ref_type, deref_type)
		{
			(
				ValueType::Array {
					element_type,
					length,
				},
				ValueType::Slice { .. },
			) => self.generate_array_slice(llvm, element_type.clone(), *length),
			(
				ValueType::Array {
					element_type,
					length: _,
				},
				ValueType::View { .. },
			) => self.generate_ext_array_view(llvm, element_type.clone()),
			(ValueType::Slice { element_type }, ValueType::View { .. }) =>
			{
				self.generate_ext_array_view(llvm, element_type.clone())
			}
			(ValueType::View { deref_type }, _) => match deref_type.as_ref()
			{
				ValueType::ExtArray { .. } => self.generate_ext_deref(llvm),
				_ => self.generate_deref(llvm),
			},
			_ => self.generate_deref(llvm),
		}
	}

	fn generate_storage_address(
		&self,
		llvm: &mut Generator,
	) -> Result<LLVMValueRef, anyhow::Error>
	{
		match &self
		{
			Reference::Identifier(name) =>
			{
				let loc = if let Some(loc) =
					llvm.local_variables.get(&name.resolution_id)
				{
					*loc
				}
				else if let Some(loc) =
					llvm.global_variables.get(&name.resolution_id)
				{
					*loc
				}
				else
				{
					return Err(anyhow!("undefined reference")
						.context(name.location.format())
						.context(format!(
							"undefined reference to '{}'",
							name.name
						)));
				};
				Ok(loc)
			}
			Reference::ArrayElement { name, argument } =>
			{
				let tmpname = CString::new("")?;
				let mut indices = Vec::new();
				indices.push(llvm.const_i64(0));
				let loc = if let Some(loc) =
					llvm.local_variables.get(&name.resolution_id)
				{
					*loc
				}
				else if let Some(loc) =
					llvm.global_variables.get(&name.resolution_id)
				{
					*loc
				}
				else
				{
					return Err(anyhow!("undefined reference")
						.context(name.location.format())
						.context(format!(
							"undefined reference to '{}'",
							name.name
						)));
				};
				let argument: LLVMValueRef = argument.generate(llvm)?;
				indices.push(argument);
				let address = unsafe {
					LLVMBuildGEP(
						llvm.builder,
						loc,
						indices.as_mut_ptr(),
						indices.len() as u32,
						tmpname.as_ptr(),
					)
				};
				Ok(address)
			}
		}
	}

	fn generate_deref(
		&self,
		llvm: &mut Generator,
	) -> Result<LLVMValueRef, anyhow::Error>
	{
		match &self
		{
			Reference::Identifier(name) =>
			{
				if let Some(value) =
					llvm.local_parameters.get(&name.resolution_id)
				{
					return Ok(*value);
				}
				else if let Some(loc) =
					llvm.local_variables.get(&name.resolution_id)
				{
					let loc = *loc;
					let tmpname = CString::new("")?;
					let result = unsafe {
						LLVMBuildLoad(llvm.builder, loc, tmpname.as_ptr())
					};
					Ok(result)
				}
				else if let Some(loc) =
					llvm.global_variables.get(&name.resolution_id)
				{
					let loc = *loc;
					let tmpname = CString::new("")?;
					let result = unsafe {
						LLVMBuildLoad(llvm.builder, loc, tmpname.as_ptr())
					};
					Ok(result)
				}
				else
				{
					Err(anyhow!("undefined reference")
						.context(name.location.format())
						.context(format!(
							"undefined reference to '{}'",
							name.name
						)))
				}
			}
			Reference::ArrayElement { name, argument } =>
			{
				let tmpname = CString::new("")?;
				let loc = if let Some(value) =
					llvm.local_parameters.get(&name.resolution_id)
				{
					let loc = *value;
					let array_loc = unsafe {
						LLVMBuildExtractValue(
							llvm.builder,
							loc,
							1u32,
							tmpname.as_ptr(),
						)
					};
					array_loc
				}
				else if let Some(loc) =
					llvm.local_variables.get(&name.resolution_id)
				{
					*loc
				}
				else if let Some(loc) =
					llvm.global_variables.get(&name.resolution_id)
				{
					*loc
				}
				else
				{
					return Err(anyhow!("undefined reference")
						.context(name.location.format())
						.context(format!(
							"undefined reference to '{}'",
							name.name
						)));
				};
				let mut indices = Vec::new();
				indices.push(llvm.const_i64(0));
				let argument: LLVMValueRef = argument.generate(llvm)?;
				indices.push(argument);
				let address = unsafe {
					LLVMBuildGEP(
						llvm.builder,
						loc,
						indices.as_mut_ptr(),
						indices.len() as u32,
						tmpname.as_ptr(),
					)
				};
				let tmpname = CString::new("")?;
				let result = unsafe {
					LLVMBuildLoad(llvm.builder, address, tmpname.as_ptr())
				};
				Ok(result)
			}
		}
	}

	fn generate_ext_deref(
		&self,
		llvm: &mut Generator,
	) -> Result<LLVMValueRef, anyhow::Error>
	{
		println!("hallo");
		match &self
		{
			Reference::Identifier(..) => (),
			Reference::ArrayElement { name, argument } =>
			{
				if let Some(value) =
					llvm.local_parameters.get(&name.resolution_id)
				{
					let array_loc = *value;
					let tmpname = CString::new("")?;
					let mut indices = Vec::new();
					let argument: LLVMValueRef = argument.generate(llvm)?;
					indices.push(argument);
					let address = unsafe {
						LLVMBuildGEP(
							llvm.builder,
							array_loc,
							indices.as_mut_ptr(),
							indices.len() as u32,
							tmpname.as_ptr(),
						)
					};
					let tmpname = CString::new("")?;
					let result = unsafe {
						LLVMBuildLoad(llvm.builder, address, tmpname.as_ptr())
					};
					return Ok(result);
				}
			}
		}

		self.generate_deref(llvm)
	}

	fn generate_ext_array_view(
		&self,
		llvm: &mut Generator,
		element_type: Box<ValueType>,
	) -> Result<LLVMValueRef, anyhow::Error>
	{
		match self
		{
			Reference::Identifier(name) =>
			{
				if let Some(value) =
					llvm.local_parameters.get(&name.resolution_id)
				{
					let loc = *value;
					let tmpname = CString::new("")?;
					let address = unsafe {
						LLVMBuildExtractValue(
							llvm.builder,
							loc,
							1u32,
							tmpname.as_ptr(),
						)
					};
					let element_type = element_type.generate(llvm)?;
					let pointertype =
						unsafe { LLVMPointerType(element_type, 0u32) };
					let address_value = unsafe {
						LLVMBuildPointerCast(
							llvm.builder,
							address,
							pointertype,
							tmpname.as_ptr(),
						)
					};
					return Ok(address_value);
				}
			}
			Reference::ArrayElement { .. } => (),
		}

		let tmpname = CString::new("")?;
		let element_type = element_type.generate(llvm)?;
		let pointertype = unsafe { LLVMPointerType(element_type, 0u32) };
		let address = self.generate_storage_address(llvm)?;
		let address_value = unsafe {
			LLVMBuildPointerCast(
				llvm.builder,
				address,
				pointertype,
				tmpname.as_ptr(),
			)
		};
		Ok(address_value)
	}

	fn generate_array_slice(
		&self,
		llvm: &mut Generator,
		element_type: Box<ValueType>,
		length: usize,
	) -> Result<LLVMValueRef, anyhow::Error>
	{
		let tmpname = CString::new("")?;
		let element_type = element_type.generate(llvm)?;
		let storagetype = unsafe { LLVMArrayType(element_type, 0u32) };
		let pointertype = unsafe { LLVMPointerType(storagetype, 0u32) };
		let sizetype = ValueType::Usize.generate(llvm)?;
		let mut member_types = [sizetype, pointertype];
		let slice_type = unsafe {
			LLVMStructTypeInContext(
				llvm.context,
				member_types.as_mut_ptr(),
				member_types.len() as u32,
				0,
			)
		};
		let mut slice = unsafe { LLVMGetUndef(slice_type) };
		let length_value = llvm.const_usize(length);
		slice = unsafe {
			LLVMBuildInsertValue(
				llvm.builder,
				slice,
				length_value,
				0u32,
				tmpname.as_ptr(),
			)
		};
		let address = self.generate_storage_address(llvm)?;
		let address_value = unsafe {
			LLVMBuildPointerCast(
				llvm.builder,
				address,
				pointertype,
				tmpname.as_ptr(),
			)
		};
		slice = unsafe {
			LLVMBuildInsertValue(
				llvm.builder,
				slice,
				address_value,
				1u32,
				tmpname.as_ptr(),
			)
		};
		Ok(slice)
	}
