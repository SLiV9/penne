import "vendor:libc/stdlib.pn";

// Of course print_slice needs to be generic over the element type (here i32).
fn print_slice(data: []i32)
{
	if |data| == 0
	{
		print!("[]\n");
		goto end;
	}

	var buf: &[...]char8 = 0x0;
	var buflen: usize = 0;

	// Do a dry run followed by a real run.
	var real: usize = 0;
	{
		var i: usize = 0;
		var writlen: usize = 0;
		{
			var fmt0 = "[%d\0\0";
			var fmt1 = ", %d\0";
			var fmt: &[5]char8 = &fmt1;
			if i == 0
			{
				&fmt = &fmt0;
			}
			var head: &[...]char8 = add_offset!(&buf, real * writlen);
			var len: usize = buflen - real * writlen;
			writlen = writlen + __snprintf!(&head, len, fmt, data[i]);

			if i == |data|
			{
				goto terminator;
			}

			i = i + 1;
			loop;
		}

		terminator:
		var head: &[...]char8 = add_offset!(&buf, real * writlen);
		var len: usize = buflen - real * writlen;
		writlen = writlen + __snprintf!(&head, len, "]\0");

		if real > 0
		{
			goto print;
		}

		buflen = writlen;
		&buf = cast malloc(buflen);
		real = 1;
		loop;
	}

	print:
	print!(buf, "\n");

	free(cast &buf);

	end:
}

// This is not the correct signature because variadics.
// builtin fn __snprintf(buf: &[...]char8, buflen: usize, fmt: [...]char8, value: i32) -> usize;
